import{_ as t,c as e,o as a,a4 as n}from"./chunks/framework.nQaBHiNx.js";const y=JSON.parse('{"title":"Animatable","description":"","frontmatter":{},"headers":[],"relativePath":"Animatable/index.md","filePath":"Animatable/index.md"}'),i={name:"Animatable/index.md"},o=n('<p><a href="./../">@plexigraph/aninest</a> / Animatable</p><h1 id="animatable" tabindex="-1">Animatable <a class="header-anchor" href="#animatable" aria-label="Permalink to &quot;Animatable&quot;">​</a></h1><p>This module deals with creating and modifying animations.</p><h2 id="index" tabindex="-1">Index <a class="header-anchor" href="#index" aria-label="Permalink to &quot;Index&quot;">​</a></h2><h3 id="type-aliases" tabindex="-1">Type Aliases <a class="header-anchor" href="#type-aliases" aria-label="Permalink to &quot;Type Aliases&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">Type alias</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="./type-aliases/Animation.html">Animation</a></td><td style="text-align:left;">The animation object. This is a recursive type, meaning that it can contain other animations.</td></tr><tr><td style="text-align:left;"><a href="./type-aliases/RecursiveAnimatable.html">RecursiveAnimatable</a></td><td style="text-align:left;">The generic type of the animation state.</td></tr></tbody></table><h3 id="functions" tabindex="-1">Functions <a class="header-anchor" href="#functions" aria-label="Permalink to &quot;Functions&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">Function</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="./functions/addLocalListener.html">addLocalListener</a></td><td style="text-align:left;">Adds a local listener to the animation. You can listen to the following events:<br>- start<br>- end<br>- bounce: hitting a bound<br>- interrupt: when a new <code>modifyTo</code> is called before the animation is finished<br>Animation listeners are scoped to only trigger when the current level of the animation is modified.</td></tr><tr><td style="text-align:left;"><a href="./functions/addRecursiveStartListener.html">addRecursiveStartListener</a></td><td style="text-align:left;">Adds a recursive start listener to the animation. This listener will trigger on any child modification.</td></tr><tr><td style="text-align:left;"><a href="./functions/boundAnimation.html">boundAnimation</a></td><td style="text-align:left;">Modifies the bounds of an object, changing what the animation is currently interpolating to.<br>Note: you might have to call <code>updateAnimationInfo</code> after this to make sure the animation is updated,<br>if the current state is outside the new bounds.<br>You can also call <code>animationNeedsUpdate</code> to check if the animation needs to be updated before calling <code>updateAnimationInfo</code>.</td></tr><tr><td style="text-align:left;"><a href="./functions/changeInterpFunction.html">changeInterpFunction</a></td><td style="text-align:left;">Changes the interpolation function of specific subproperties based on the mask.<br><br>Note: you only have the granularity of each dictionary level. For instance,<br>if you had the following animation structure:<br><code>const anim = createAnimation({a: {x: 0, y: 0}, b: {x: 0, y: 0}}, getLinearInterp(1))</code><br>then you could change the interpolation function of <code>a</code> and <code>b</code> but not <code>a.x</code> and <code>a.y</code>.<br>To change <code>a.x</code> seprately from <code>a.y</code>, this would be your structure:<br><code>const anim = createAnimation({a: {x: {value: 0}, y: {value: 0}}, b: {x: 0, y: 0}}, getLinearInterp(1)) // only changes</code>a.x<code>interp function changeInterpFunction(anim, getLinearInterp(2), {a: {x: true, y: false}, b: false})</code><br>Then to get the value of <code>a.x</code> you would call <code>getLocalState(anim.children.a.children.x).value</code>.<br><br>To get the <code>value</code> of both <code>x</code> and <code>y</code> and simply store set the variables <code>x</code> and <code>y</code> to the<br>respective values you could do:<br><code>const {x: {value: x}, y: {value: y}} = getStateTree(anim.children.a)</code></td></tr><tr><td style="text-align:left;"><a href="./functions/createAnimation.html">createAnimation</a></td><td style="text-align:left;">Creates an animation info object, automatically inferring type from the init object.</td></tr><tr><td style="text-align:left;"><a href="./functions/getInterpingToTree.html">getInterpingToTree</a></td><td style="text-align:left;">Gets the total target state that the animation is currently headed to.<br>If the animation is not headed to any state, it will return the current state.</td></tr><tr><td style="text-align:left;"><a href="./functions/getLocalInterpingTo.html">getLocalInterpingTo</a></td><td style="text-align:left;">Gets the local target state that the animation is currently headed to.<br>If the animation is not headed to any state, it will return the current state.<br>This only returns the local state of the animation, meaning only the numbers<br>in the topmost level of the input animation.</td></tr><tr><td style="text-align:left;"><a href="./functions/getLocalState.html">getLocalState</a></td><td style="text-align:left;">Gets the current local state of the animation, meaning only the numbers in the topmost level of the input animation.<br>To access the local state of a child, use <code>anim.children.childName</code> as the input.</td></tr><tr><td style="text-align:left;"><a href="./functions/getStateTree.html">getStateTree</a></td><td style="text-align:left;">Gets the total state of the animation, including all children.</td></tr><tr><td style="text-align:left;"><a href="./functions/modifyTo.html">modifyTo</a></td><td style="text-align:left;">Sets the final stopping point of the animation.<br>The animation will start to interpolate to the new state.</td></tr><tr><td style="text-align:left;"><a href="./functions/removeListener.html">removeListener</a></td><td style="text-align:left;">Removes a listener from the animation</td></tr><tr><td style="text-align:left;"><a href="./functions/removeRecursiveStartListener.html">removeRecursiveStartListener</a></td><td style="text-align:left;">Removes a recursive start listener from the animation</td></tr><tr><td style="text-align:left;"><a href="./functions/updateAnimation.html">updateAnimation</a></td><td style="text-align:left;">Updates the animation by incrementing the current timestamp of the animation by <code>dt</code>.</td></tr></tbody></table>',8),l=[o];function r(d,s,c,h,f,m){return a(),e("div",null,l)}const g=t(i,[["render",r]]);export{y as __pageData,g as default};
